！！！！！集群！！！！！
代理的作用：帮你干活的人，nginx代理
你想上网，但是和对应网页不是同一网段，代理是与客户联通的，也与对应的网站联通
为什么有代理：一方面是帮助用户上网，一方面保证安全性，还有最重要的就是调度作用！用户访问代理时，它会将大部分访问量分散发给其他服务器，将负载均衡！
具体操作：
先将后端的两台web服务器搭上，后台两台机器可以用nginx也可以用apche，如果有防火墙关，有selinux关
web1 和 web 2的网页内容应该是一模一样的，但是为了看出结果，所以不能做一样
web1:
yum  -y  install  httpd
echo '123' > /var/www/html/index.html
systemctl restart httpd
irewall-cmd --set-default-zone=trusted
setenforce 0
web2:
yum  -y  install  httpd
echo '456' > /var/www/html/index.html
systemctl restart httpd
irewall-cmd --set-default-zone=trusted
setenforce 0
然后再设置proxy的配置，不让它做web服务器，让它变代理
vim /usr/local/nginx/conf/nginx.conf
在server外面写
upstream webserver {            #定义一组集群，后面的是集群名字
 server 192.168.2.100:80;       #第一台后台服务器
 server 192.168.2.200:80;       #第二台后台服务器
}
上面这些算是定义集群
以下是调度
server {
        listen   80;
        server_name  www.d.com;     
        location / {
        proxy_pass   http://webserver;  #调用集群！proxy_pass是调用的固定命令
        #    root   html;      集群的优先级高于root
        #    index  a.html;
        }
    }
然后用客户端去做访问www.d.com看效果
当web1坏了，web2可以继续工作，起到冗余的效果

***********************************************************************************************************************

！！！！！！设置集群！！！！！！！以下测试可以用systemctl stop httpd命令来停止指定服务器的web
http {
.. ..
upstream webserver {
                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                server 192.168.2.101 down;
        }
#weight设置服务器权重值，默认值为1，当增加数量的时候，就会多接受几次请求
#max_fails设置最大失败次数，如果达到最大访问次数访问不了，就不让这台服务器解决了
#fail_timeout设置失败超时时间，单位为秒，如果达到最大失败次数，等30秒之后再回来测试。
#down标记服务器已关机，不参与集群调度
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}

**********************************************************************************************************************
  
配置upstream服务器集群的调度算法  属于iso7层http调度
默认是轮询算法，但是客户如果一旦涉及登陆页面，如果是轮询，就要反复登陆，所以必须要改
要做到相同客户端访问相同服务器需要利用ip_hash; 调度器在拿到客户的访问请求时，会看客户端ip地址，
并且echo "ip" | md5sum 进行计算，产生的这个一串数字就只和ip地址有关系，
但是并不是看全部的ip地址，只看前24位，计算之后产生的是一串16进制数。
将这串16进制数%2 与2取余数，所以所得结果只会是0或者1， 
有几台服务器与几取余数，所得结果范围是 0-（x-1）所得结果就是集群里的对应服务器

http {
.. ..
upstream webserver {                                  
                ip_hash;         #通过ip_hash设置调度规则为：相同客户端访问相同服务器
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;  #这是第一台服务器0
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;  #这是第二台服务器1
        }
.. ..
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}

**********************************************************************************************************************************

！！！！！Nginx的TCP/UDP调度器 iso4层调度！！！！！
前面的调度只能做WEB调度，万一后台是FTP DNS MYSQL服务就不行了，用这个nginx四层调度就可以了！
但是只有nginx1.9版本以后才支持的，且是单独的模块 --with-stream  没有的话只能重装，可以利用升级安装功能，
当然要先停止nginx的服务，才可以killall nginx
客户端连接不上内网的服务器，就可以先连nginx代理，让它去找内部网络的服务器

案例场景：员工回家之后还想ssh远程连接web1 web2工作，但是web1和web2是内部网络，这时候就需要nginx代理
此时修改/usr/local/nginx/conf/nginx.conf配置文件
一定要写在http外面，因为是4层调度！
stream {
            upstream backend {
               server 192.168.2.100:22;            //后端SSH服务器的IP和端口，如果想做别的服务调度，就改别的端口号
               server 192.168.2.200:22;              指定的是端口号，当客户想ssh这两台机器时，就ssh这台nginx代理服务器的指定端口号
}
            server {
                listen 12345;                      //告诉nginx用哪个端口来服务，最好是没用的端口
                proxy_connect_timeout 1s;          //连接超时时间，只等1秒，客户连接访问时，1秒没响应就报错无法访问
                proxy_timeout 3s;                 
                proxy_pass backend;                //转发！当客户端访问12345指定端口访问nginx代理时，就交给backend集群处理
             }
}
http {
.. ..
}

客户验证：ssh -p 12345 192.168.4.5  -p指定端口

************************************************************************************************************************************

！！！！！怎么优化nginx服务器！！！！！
第一个优化：优化使用体验
如何自定义报错页面
将这一行的注释打开error_page 404 /404.html；    #要出现的页面是啥就写啥，注意要放在网站根目录里
还要加一行charset utf-8;
最后别忘了重启服务
常见错误返回码：
200正常  300类是重定向 
400类是用户错 401用户名密码错误 403禁止访问 404文件不存在  414url输入过长 
500服务器自己内部错   502集群里的服务器错了

****************************************************************************************************************************

--with-http_stub_status_module  查看详细数据的模块！也不是默认安装的
我想知道这台服务器，有多少人在访问，有多少人在等待，这一个月有多少访问量
在sever里加一个location地址指定页面
location /status {                 #这个网站根目录后面写得什么，访问时就打什么，这个页面是模块功能提示的，所以不用创建
                stub_status on;    #这个打开了，数据就能看了，但是默认谁都能看
                 allow 管理员自己ip;   #只允许自己访问
                 deny all;           #禁止所有人访问
        }

该网页显示详细信息：
http1.0版本，3次握手，一次请求一次断开，所以来回建立连接很浪费流量
http1.1版本，3次握手，多次请求，但是长时间没有操作30秒左右，就会断开    节约流量，与时间
Active connections：当前连接网页的用户数量。
第一个数字是用户发了多少次连接Handled， 第2个是用户处理了多少连接accepts， 第三个数字是用户的服务请求次数Requests。  
以上所有数据都是，打从服务器启动就一直在的，不是实时的值，是累计的

*******************************************************************************************************************************************

Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。
什么时候做集群：分静态页面和动态页面
静态页面：用户访问页面，占用的是nginx服务器的网卡带宽（千兆万兆）和内存（128G）   当然所有都是从硬盘开始读取的（ssd固态硬盘只有三星和因特尔好用）
动态页面：（脚本）执行代码需要CPU，动态网站并发量非常低   当然所有都是从硬盘开始读取的

****************************************************************************************************************************************************

第三个优化，增加并发量  
输入命令测试：ab -c 100 -n 100 http://192.168.4.5/    100个人同时访问，100个人一共访问了100次。
ab是一个测试软件，c模拟有100个人同时去访问这个网站，n后面写的是最终访问次数是100个人一共访问100次。可以用别的并发量测试软件
通过测试可以发现，大概达到1000多并发量就不行了

这时候就需要修改nginx配置文件了！
worker_processes  2;             //与CPU核心数量一致，你cpu是几核就写几核
events {
worker_connections 65536;        //每个worker最大并发连接数后面随便写往大了写
use epoll;                      //不用写，是默认工作方式，apche的工作方式是select，
                                            核心区别是，一个带着去找网页，一个只是指明网页位置，这样就提高了并发量
}
.. ..

还需要修改优化linux最大允许开启文件数量！默认只允许有1024个文件同时打开
ulimit -a可以查看所有用户的限制，电脑最多可以开3845个线程
改配置文件其中两行！实现永久！但是得重启！
vim /etc/security/limits.conf
   .. ..
*               soft    nofile            100000      *是指对所有人限制
*               hard    nofile            100000
临时调整文件开启数量命令，使其立刻生效：
ulimit -Hn 100000     （硬限制）打开数量达到数值就不能打开了
ulimit -Sn 100000      (软限制)就只是报警

做完以上两个大步骤，大概并发量可以达到6000左右了

********************************************************************************************************************************************************

如何让客户在地址栏可以输入更长的字符串，即414错误！
工作原理：
 当客户访问nginx服务器时，输入www.a.com，客户的电脑会将这个请求数据多次封装，传给nginx服务器对应的网卡，然后它的网卡会将这个请求数据包放到内存里，
 nginx对应端口程序会去内存里解封装
用户如果在地址栏输入了很长一串url后缀时，默认只允许niginx的url数据占用1K的内存空间，修改nginx配置文件即可
vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;        //默认请求访问数据包的包头信息的缓存    包头即网络中的数据封装里的包头    
large_client_header_buffers  4 4k;      //最大请求包头部信息的缓存个数与容量    
.. ..
}

别忘了要重启服务

**********************************************************************************************************************************************************

！！！！！！！！！设置浏览器本地缓存数据！！！！！！！！！！！！！
所有浏览器都有缓存数据
在火狐浏览器地址栏输入about:cache查看详细缓存数据
有缓存的话，就会直接存放到客户的机器里，这样下次看就不用再下载了。缓存一般在客户的c盘。
所以要设置缓存失效时间，否则客户看不到更新之后的页面。用户的缓存只适合静态数据，如图片，视频，音频。
但是价格这类实时变的数据一定不要缓存。
定义缓存，打开nginx配置文件，单独写一个缓存location
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {           只要是以jpg.gif.png等结尾的文件目录
expires        30d;            //定义客户端缓存时间为30天          委托浏览器帮我们缓存30天
                    }
          }
如果有特殊要求，可以一个类型写一个location，改完配置文件，别忘了重启服务

****************************************************************************************************************************************************************

日志切割
/usr/local/nginx/logs 底下的日志  当日志大到了几个G就打不开了，所以要做切割
apche可以自动备份，但是nginx没这个服务，因为是源码安装的，如果不管问题就会非常大
1.mv access.log access-20190122.log  将老日志改名,这个是成功日志，做备份access.log这个日志是所有记录的文件
  mv error.log error-20190122.log               这个是失败日志
2.kill -USR1 9031     这条命令可以再创建一个新日志，是通知nginx让它新建日志，因为老日志被移走了   9031这个ID可以用cat /.../logs/nginx.pid查看nginx的pid      
pgrep 程序名 也可以查pid
kill这个命令核心功能是给指定进程发送信号。当kill后面不打选项时默认是kill -15这个命令不是强制，-9才是强制！
kill不一定是要杀死进程，主要是传信号，后面跟各种选项

kill -19 pid 是让进程先挂机
kill -18 pid 是让停止的进程恢复

为了能够让nginx每天可以自己备份日志，先把那俩命令写脚本里，再放入周期计划任务里自动执行
vim /usr/local/nginx/logbak.sh
	#!/bin/bash
	date=$(date+%Y%m%d)
	logpath=/usr/local/nginx/logs
	mv $logpath/access.log  $logpath/access-"$date".log
	mv $logpath/error.log  $logpath/error-"$date".log
	kill -USR1 $(cat $logpath/nginx.pid)

然后再写周期任务：
crontab -e
03 03 * * 5  bash /usr/local/nginx/logbak.sh

******************************************************************************************************************************************************************

对网页进行压缩！nginx有压缩功能，所有浏览器都支持解压，所以用户看不出来效果
本来是用户要啥给啥，但是需要优化，先把页面压缩再传
好处：带宽相同，必然压缩的传的快，可以为用户省流量
打开nginx配置文件，在sever外面写

http {
.. ..
gzip on;                            //gzip是开启压缩，而tar是打包的意思，gz是压缩的意思，写全了就是gzip
gzip_min_length 1000;                //文件最小如果不到1000bit就不压缩，否则越压越大
gzip_comp_level 4;                //压缩比率1-9选一个，数字越小，压缩效果越差，但是cpu计算时间越短，所以中间值最好
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //只对特定文件压缩，多媒体文件尽量不要压缩，因为本来它们就是压缩格式！对文档类压缩效果特别好！ 以上文件类型参考mime.types这个文件，
.. ..                                这个文件在conf路径下，打开之后第一列是文件类型，nginx配置文件里要写文件类型名 第二列是扩展名，不能写扩展名    
}

题外：无损音乐的格式是APE Flac 	

******************************************************************************************************************************************************************

速度排行
1.GPU显卡
2.CPU
3.内存
4.硬盘 而nginx就在硬盘里！nginx服务器可以单独让服务器上的内存分一些空间给它自己。
  将其作为缓存写入内存条，客户再访问，直接从内存扔缓存给客户端，这样可以极大的提高访问速度！
配置nginx配置文件，写在http里sever外面

    http { 
    open_file_cache          max=2000  inactive=20s;    #前面是固定语句，是打开缓存的意思，最大缓存2000个文件，因为内存特别珍贵，所以设置20秒内没人访问就清空缓存
    open_file_cache_valid    60s;                       #文件缓存最大有效期只有60秒，不管有没有人访问
    open_file_cache_min_uses 5;                         #只有一个文件被访问5次以上才作为热点文件，只有热点文件才缓存
    open_file_cache_errors   off;                       #缓存里如果出错了，不要报警，不要报错，不要写日志里！因为缓存变更特别频繁！
    } 

以上一共8个优化

******************************************************************************************************************************************************************















