
当我们插入表记录时！插入的一定是完整的一行，无法改变！

一、建表时字段的约束条件：
		也就是表结构中，最后的4列（Null Key Default Extra）
	1.Null是否允许为空：
		null：允许列值内容为空，如果不更改该约束条件，默认允许表记录为空
		Not null：不允许为空
	2.key键值：给表字段的记录做索引！
		key键值类型：也叫索引类型！
		1）index:普通索引
			什么是索引：索引就是给表字段的值进行某一种方式排序，以此来方便查找！
			索引类型：也就是排序方式包括Btree、B+tree、hash，默认是Btree排序方式
			 	Btree（二叉树）：
				模型：
				            4
					2       6
				     1     3  5    7
			索引的有点：以Btree排序方式为例
				每一个节点都有俩分支节点！好处就是，当我们要查一个数时，自动和4做比较，比4大，就去右边找，这样！就少找1/2的数，极大提高查寻速度！
			索引的缺点：
				缺点就是占用空间，你做一个索引，要存到linux系统的对应文件里，如果列值特别的多，它就要写一个很大一个排序信息！
				且当列值发生更改时，原来的排序方式就不能用了，系统就要重新排序！系统维护数据慢！
			index键值使用规则：
				一个表中允许有多个index字段，各个列里面的值允许有重复，且允许值是空值null，但是你要是指定约束条件not null了，那赋值就不能为空了！
				通常把经常做查询的字段设置为index字段
				index字段的标志是mul，也就是说查看表结构时key那列，设置了index索引的表字段，显示的是mul。
			两种方式给列做索引：
				1.建表的时候，指定约束条件key的类型时指定index索引：
					create table t2（class char(7),index(class)）;  
					#指定索引类型时，写在最后，要给哪列设置索引，括号里写就行了，class这列值的排序信息会自动存到它的表文件里也就是/var/lib/mysql/t2.*
					
				我们可以通过指定查看class列的某个内容，来查看索引之后的结果！如果我们看的是整个表时，是不会显示class列的索引后的结果的，查看方法：
					select * from t2 where class="...";

				如果我们想查看t2表哪一列使用了索引，使用的是哪种索引类型，可以通过命令：	show index from t2\G；  
					显示出来的信息中：
					***1.row***  这个表示的是一列的详细键值信息！
					Table：写的是查询的表名 
					Key_name:
						写的是键值名称（索引名称）！这个名称和列名同名，想删除这列的索引时，就要借助它
						删除某列索引的方法：drop index 索引名 on 库名.表名；
					Column_name:写的是哪一列做了索引 
					Index_type:指这列的索引类型
					
				2.在已有的表里，给没有设置键值的列指定索引名称！那系统会自动给这列做索引排序，还会给其指定索引名称，我们最好让索引名称等于列名，方法：
					create index 索引名称 on 表名（列名）；
					#例如create index class on t2(class); 这样就会自动做普通索引（index），我们查看表结构时，key那一列对应class的那一行就变成了mul！ 

			2）unique：唯一索引 不常用
			3）fulltext：全文索引 不常用
			4）primary key：主键
				主键使用规则：
					一个表中只能有一个primary key主键字段，设置主键的字段中的值不允许有重复，且赋值时不能是null空值！
					如果有多个字段都要设置主键，称为复合主键，必须一起创建，如果已经有一个主键字段了，你还想再设置一个主键字段不行！
					主键在key中的显示是RPI
					通常与auto_increment（自增长）连用，自增长就是做i++运算
					经常把表中唯一能够标识记录的字段设置为主键字段，就好像人名可以重复，但是身份证号不能重复，那么身份证号这一列就可以设置为主键字段！这样便于查找！
				创建主键primary key：我们创建主键的目的是，希望列值不重复且不为空！
					创建表时，指定列做主键：
						create table db2.t3(stu_num char(10),name char(10),primary key(stu_num));
						create table db2.t3(stu_num char(10 primary key,name char(10)); 
						#这就是创建表时把stu_num这列设置成了主键！这两种写法都行！
					在已有表里添加主键：
						1）在已有表里时，如果已存在的表字段中有值，那么你想添加一列新的字段，并把这个字段设置成主键是不可以的，
						因为它和已有的列值自动组成一行信息，
						而它那列里面是没有值的！主键不允许有空值！也不允许重复！除非你把整个表记录全删除 delete * from 表名; 再增加新的主键列 
						要么与auto_increment结合使用
							命令：alter table t2 add stu_num primary key after class;
							#给t2表添加一列stu_num列，并把它设置成主键，让它在class列后面
						2）把表里已有的列设置成主键，前提要求值不能有重复和空值：
							命令：alter table t2 add primary key（stu_num） after class; 
							#我们给t2表里的stu_num列设置主键，并让它挪到class列后面,1)2)命令一样 
					创建复合主键：
						应用场景：比如你有两列，他们中的一列值可能有重复，无法确定唯一性，但是和别的列组合起来一起判断，就能确定唯一性了！
						可以给多列做复合主键，这些列里的值只要没有同时都重复，就可以赋值，但是要求主键列不能赋空值！
						如果你想有多个列都想做主键，就必须是创建表的时候就创建！
						命令：create table t3(name char(10),class char(10),status enum("yes","no"),primary (name,class));
						验证下：insert into t3 values("bob","1811"); 
							insert in t3 values("bob","1812");
					auto_increment自增长：它是功能，不是约束条件，也不是字段类型！
						作用是让字段的值自增长，要求这个字段类型必须是数值型，且这个字段必须是主键才能设置自增长！
						命令：create table t4(id int primary key auto_increment,name char(10),sex enum("girl","boy"));
						设置了自增长，就可以不用赋值了！默认第一行从1开始做+1运算！
						如果你想给某一行信息改一个指定数值也可以，比如赋值=9（但是不能与这列已有的值重复）
						相对的你再写下一行，会变成它上一列+1，也就是10，而且自增长这个功能是有记录的！
						比如你这列最后一行是10，即使你把整个表记录全删除了，重新写，自增长会让这列的新值变成10+1！
					删除主键：
						alter table t2 drop primary key;   
						#就是删除t2表里的主键，但是如果这个主键设置了自增长！就不能删除，必须修改掉：
							alter table t2 modify id int not null; 这样就是把原来的字段类型抄一遍，自增长类型就没了！
					验证主键：
						insert into t2(stu_num) values(1231);
			5）foreign key：外键
				外键的作用：
					假设你公司里有两个表，一个员工表有一列是员工姓名，一个工资表里面也有一列员工姓名
					让这个工资表的员工姓名列，做员工表的员工姓名列的外键，也就是说它是次要列！
					那么你想往工资表里员工姓名这一列写员工名，就只能写员工表里的员工姓名列里存在的员工姓名！
					这样不就能保证工资不会发丢了嘛，要不财务随便往工资表里面写员工名就糟糕了
				外键使用规则：
					表的存储引擎必须是innoDB（引擎的知识比较多，后面再详细解释）
						我们可以查看一下表用的什么存储引擎：show create table t2;
						ENGINE=写的就是存储引擎的名字 （5版本默认用的就是innoDB引擎）
						我们创建表时可以指定引擎：create table db2.t4(...)engine=innodb; 
					两个表的两个字段类型必须一致，列名最好一致，也可以不一致，不一致怕混淆！
					作为外键的那个表里的字段必须是索引类型的一种，你不设置，默认是mul也就是index索引，
					通常我们都把要做外键这一列设置成主键primary key，为的是列值不重复不为空，更加容易做参考！	
				外键的注意事项：
					当你的员工表中的员工id 做为 工资表的员工id外键的参考列时，这个员工表是无法被删除的！员工表里员工id这一列也无法被删除
					当你员工表中员工id这列的内容删除的时候，工资表也没了！
				创建外键：
					现在我们来创建员工表：
						create table 员工表（员工id int primary key auto_increment,
								员工姓名 char(10),员工性别 enum（"男","女"））
								engien=innodb default charset=utf8;
						#这就创建员工表，有3列(员工id设置主键和自增长、员工姓名、员工性别）并指定引擎，和支持万国码!
						然后我们往这个表里插入记录：
						insert into 员工表（员工姓名 员工性别） values("bob","男"),("lucy","女"),("lisi","男");
						#这样添加可以同时写多行记录！因为员工id是自增长，所以它会自己增加记录不用管！
					现在我们要创建作为外键的工资表：
						create table 工资表(员工id int,工资 double(7,2)) engine=innodb default charset=utf8;
						#员工id这一列的字段类型也要是int，与它的父列相同才行
					然后创键外键：
						1.创建表的时候，创建外键：
							create table 工资表(员工id int,工资 double(7,2)
							foreign key(员工id) references 员工表（员工id列）on update cascade on delete cascade）engine=innodb; 
						#创建工资表写两列 员工id（int类型）工资（double类型），让工资表的员工id列做外键，参考的是员工表中的员工id列的值！
						#并且与参考的字段表记录同步更新，对面改它也自动改，也同步删除！指定引擎是innodb
						#创建完外键之后，通过desc 表名; 看一下表结构，发现设置外键的列，变成key的类型变成mul了，也就是自动做了索引！
						#我们可以通过命令： show create table 工资表； 来查看键表，显示内容如下：
							KEY `字段名`（`索引名称`）， #这个写的是给这列自动做了个索引，索引名称和字段名称一样
							FOREIGN KEY（`工资表_员工id`）REFERENCES `员工表`（`员工表_员工id`）ON UPDATE CASCADE ON DELETE CASCADE
								#这行写的就是设置外键的信息
                       				现在有这样一个问题：工资表这个外键的表，是可以反复添加员工id的，只要写的id在员工表里是存在的，就能反复写入！但是这样不合理
						这样不就相当于给一个人发了多遍工资了吗，而且现在也允许在工资表里给员工id赋空值null！怎么解决？
						所以应该给工资表的员工ID这列，也设置主键就合理了：alter table 工资表 add primary key(员工id);
						2.给已有表里的列创建外键：
							前提你要满足外键的规则！要和参考表的那一列字段类型一致，不能有和参考列里没有的值！还有索引类型，引擎等！
							添加外键命令：
							alter table 工资表 add foreign key(员工id) references 员工表（员工id） on update cascade delete casade;
				验证外键：
					如果员工表里的员工ID列有3行值，分别是123，我们往工资表里的员工ID列添加表记录的时候也就只能添加123这3个数据：
						insert into 员工表 values(1,20000);   #这个20000是员工工资那列！ 
					如果员工表里bob这个人的员工id是2，我们给它改成8：update 员工表 set 员工ID=8 where name=bob；
					因为我们创建工资表的时候开启了自动更新和自动删除功能，所以工资表中对应的2那行也自动变成8了！
					如果员工表里删除一行：delete from 员工表 where 员工id=8；那外键也会删除对应ID的行！ 
				删除外键：
					我们要删除外键这个索引类型，可以先 show create table 工资表;  来查看工资表的约束条件
					CONSTRAINT `工资表_ibfk_1` #这个 `` 里写的就是外键的名称！
					然后复制外键名称 alter table 表名 drop foreign key 约束名;   #约束名写外键名称即可删除外键的约束


	3.Default：设置默认值，缺省为null
		我们创建表的时候，可以给表字段设置默认值，当我们插入表记录时，不赋值，就自动存默认值，如果不设置默认值，默认就是null空值
		当我们自己写入表记录时，就和默认值没关系了。
		例：
	  	create datebase db2
	  	create table db2.t1(age int unsigned not null default 18,name char(10) not null); 
			#创建表二，里面写一列age，写表记录时不能写负数，赋值不能赋空值，默认值是18，一列name，字符型，长度10，不允许为空
			#注意默认值要符合表字段类型！其中说了赋值时不能为空！虽然有默认值，但是也会报错！
                	#也就是说，你的默认值在不允许赋值为空的约束条件下，是不生效的！
	  	insert into db2.t1 values("","null")；
			#给列赋值时，""表示的是写一个空格，而不是空值！"null"加引号表示的是null这个字符！真正的空值是什么都不写或者你写一个null不加引号！
			#以此可知，我们设置默认值的时候，可以 default "" 这样就是说默认值是赋一个空格，而不是查看表结构时显示null了  
	4.Extra：额外设置，通常是设置字段能不能自动增长auto_crement
	


二、修改表结构：修改表中已存在的字段类型和约束条件
	alter table 库名.表名 执行动作;
	执行动作包括：
		1）add 添加表字段
			add 字段名a 类型（宽度） 约束条件；
			#我们往表里增加一列，类型必须要写！约束条件如果不写，系统自动设置！
			add 字段名a 类型（宽度） 约束条件 after 字段名b；
			#写after 字段名b 就是指定插入的位置，把字段a这一列插入表中已有的字段b后面， 如果想插在首列after就改成first,不指定位置，插入到最后！
		 例：alter table db2.t1 add a int default "" after b;
		2）modify 修改表字段类型
			modify 字段名a 类型（宽度） 约束条件;
			#我们修改a这一列的值，类型必须写，约束条件不写，系统自动设置！且新修改后的规则不能与字段里已有的表记录冲突！否则无法修改！
			modify 字段a 类型（宽度） 约束条件 after 字段b；    
			#我们改完a这列的表字段之后，也可以给它改位置，放到字段b后面，first是放在列首
		 例：alter table db2.t1 modify a tinyint not null;
			#以 1）的例子做修改解释，a这列变成了，字段类型变成了tinyint，且输入表记录时不允许为空，并且变成了最后一列！
			#如果不想改的就原样抄下来，否则会变成系统自定义的设置
		3）change 修改表字段名
			例：alter table 表名 change 源字段名 新字段名 类型（宽度） 约束条件；
			#也可以改列名的同时，改字段类型和约束条件！如果只想改名就直接原样抄下来！
		4）drop 删除表字段
			drop 字段名a，字段b； 
			#可以同时删除多列，并且会连列里面的内容一起删除。
			例：alter table db2.t1 drop a；
		5）rename 修改表名
			例：alter table 库名.源表名 rename 新表名；   
			#当表名更改了，linux系统里的对应文件/var/lib/mysql/....也会改名！























































