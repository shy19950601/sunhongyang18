redis主从同步：
	实验前准备：我们需要51-58这8台redis服务器！要求它们是独立的redis服务器！把它们的数据库目录清空！集群文件也删除掉！每一台都要这么操作！
		先停服务：/etc/init.d/redis_6379 stop
			rm -rf /var/lib/redis/6379/*
		然后修改配置文件，把集群功能注释掉
			注释掉下面3行
				cluster-enabled
				cluster-config-file nodes-6379.conf		
				cluster-node-timeout 15000
		再启服务：/etc/init.d/redis_6379 start

主从模式结构：
	查看主从关系信息的命令：
		info replication
	临时为从库指定主库的命令：
		slaveof 192.168.4.1:6379
			#所要指定的主库ip：对应redis端口号
	临时将从库恢复成主库的命令：
		因为任意一台主机redis服务运行后，默认都是主库，这条命令立刻生效！如果配置文件改了设置从库的参数，重启服务，这台机器又变为从库了
		slaveof no one 
		
	1）一主（192.168.4.51）一从（192.168.4.52）
	 	所以默认51就是主库了，我们配置52的配置文件做51的从库：
			slaveof 192.168.4.51:6379
			然后51和52都看一下状态：info replication
		我们需要去改52从库的配置文件，来做到主从配置永久生效：
			先去停一下redis服务
			再改/etc/redis/6379.conf文件
				在282行 slaveof <masterip><masterport>  #将这一行注释去掉，然后写主库的ip和主库的端口
			停一下redis服务
			再启动redis服务
	1.1）配置有密码的主从结构：
		在51主库设置连接密码：
			改/etc/redis/6379.conf文件 的501行即可，之前的文档里有密码配置方法
			改完重启服务（别忘了脚本不能停服务了，用命令停服务）
		在52从库指定主库的连接密码：
			先停一下服务
			改/etc/redis/6379.conf文件
				改第288行 masterauth "这里写主库密码" 	#把这行注释去掉，然后改一下
			再启动服务

	！！！！！！！需要注意的是，非集群的主从同步，从库默认设置是不能存数据的！！！！！！！

	2）一主多从 
		51做主库 52做从库 53做从库
		这个配置方法和上面一模一样，无法就是重复一遍从库的配置
	3）主从从：
		51做主库 52做从库 53做52的从库
		假如你53上有数据，你把53配置成52的从库之后，53上的数据会自动清空，并同步52的数据！
		52虽然作为53的主库，但是它还是51的从库，它的身份在自己的状态显示信息（info replication）中，就是从库身份！
		52不用做其他操作了，如故你需要给52设置个密码，那就设置个密码！
		53的操作和上面的设置从库操作是一样的！

主从复制的工作原理：
	首次同步：
		从库向主库发送sync命令，主库会启动第二个进程在后台运行，并收集所有修改数据的命令，收集完成后存盘，传送整个数据文件（dump.rdb）给从库服务器，
		然后从库将接收的数据加载到自己的内存里
	后续新增同步：		
		后续有新数据增加时，主库继续将新的数据收集到的修改命令依次传给从库，完成同步
主从复制的缺点：
	网络繁忙时，会产生数据同步延时的问题
	系统繁忙时，会产生数据同步延时的问题

主从模式中的哨兵模式服务： 哨兵服务的默认端口号是 26379
	作用：用于监控主库，当主库坏掉的时候，自动将从库升级为主库！
	需要单独一台机器提供监控服务，也可以把这个哨兵服务放在从库上，这样不是省机器吗
	哨兵服务是redis服务里自带的功能，想要开启哨兵服务，创建哨兵服务的配置文件即可
		哨兵服务的部署：
		1.有redis服务环境
		2.创建哨兵服务的配置文件
			有模版配置文件，不需要手动写，在redis-4.0.8这个源码包里有个sentinel.conf
			复制并修改这个模版文件的指定行，写成新的配置文件：
				vim redis-4.0.8/sentinel.conf
				复制第6行： bind 0.0.0.0 192.168.1.1	#0.0.0.0是说我所有的ip地址都用于哨兵服务的通信
				复制第69行：sentinel monitor haha 192.168.4.51 6379 1
					#haha是我哨兵给这台主库服务器取得名字		
					#指定监控哪台主库服务器ip和对应的redis端口号，
					#最后的1是哨兵服务器的判断的投票数，有几个哨兵服务器判断这台主库坏了，才算真坏，我们只有一台哨兵服务器，所以就写1
				复制第71行：sentinel auth-pass haha 123456
					#如果我这台主库服务器是有密码的，那么我要把这一行注释打开，来告诉哨兵服务器连接主库的密码
					#haha是哨兵给主库服务器起的名字
					#123456是连主库用的密码
			把这3行复制并写入/etc/sentinel.conf 这个文件没有，你自己创建
			然后启动哨兵服务：
				命令：redis-sentinel /etc/sentinel.conf
		3.测试即可：
			关掉哨兵监控的主库，看是否执行了健康检查，从库自动切换成主库了，然后这个切换成主库的从库，就会变成哨兵服务器的新监控对象
			如果你哨兵服务器就是这台升级为主库的从库服务器，那就没什么意义了，所以才建议单独用一台服务器做哨兵监控服务器
			查看哨兵服务的监控信息变化：cat /etc/sentinel.conf
		现在有这么一种情况：
			比如51是主库，52是51从库，53也是51从库，假设51设置了密码，52 53没有设置密码，我们完成了一主多从结构的搭建，一旦51坏掉，52被哨兵服务切成主库服务器
			那53也自动会把52当作新的主库，但是此时52上面是没有密码的，可是53却设置了连51的密码，这个时侯，53就无法连接52，需要53去配置文件把连接密码删除掉，
			或者你51 52 53都设置相同的密码！
*************************************************************************************************************************************************************************

redis数据持久化
	什么是持久化：
		将内存中的数据定期自动保存到硬盘里。
	持久化的方式：
		RDB：
			指的是redis数据库文件（dump.rdb）,简称rdb(数据文件存放在/var/lib/redis/6379/dump.rdb)
			rdb是数据持久化方式之一，按照指定时间间隔，将内存中的数据集快照（术语叫做Snapshot快照）写入硬盘！
			恢复数据时，直接将快照文件直接读入内存
			关于redis数据恢复与备份的相关内容：
				备份恢复就是把dump.rdb文件做备份恢复操作，里面存的全是redis数据库的变量
				redis除了按照时间间隔进行数据备份，当你停止服务的时候，它也会把内存里的数据往dump.rdb文件里存
				比如你想让56的数据和55一样，那就把56的dump.rdb文件删除掉，把55上的dump.rdb文件拷贝过来
			下面来演示一下用RDB同步数据：
				56上操作：
				1.先连上redis数据库：redis-cli -a 你的密码
				2.保存当前内存中的所有数据到dump.rdb文件中：save
				3.退出即可
				4.把这个dump.rdb文件scp给55服务器
				55上操作：
				先停数据库服务
				1.把本机的dump.rdb文件删除
				2.把56的dump.rdb文件拷贝到/var/lib/redis/6379/目录下即可	
				再启动数据库服务即可完成同步
			在主配置文件中与RDB文件相关的配置项：
				vim /etc/redis/6379.conf来看一下相关的行
				254行	dbfilename dump.rdb	#指定在数据存储目录下的哪个文件用于存储数据，没有找到这个文件，它就自己创建
				219行 save 900 1	#这是说，每900秒执行一次存盘操作，但是前提是有一个变量发生了变化
 				220行 save 300 10	#每300秒执行一次存盘操作，前提是有10个变量发生了变化
 				221行 save 60 10000	#每60秒执行一次存盘操作，前提是有1万个变量发生了变化，这三条条件都生效，条件可以有多条！
				217行 save "" 	#就是不启用RDB持久化！默认RDB就是启用的，所以这一行是注释掉的
				
				RDB它的保存操作我们可以理解为是覆盖重定向！每次都把内存中的数据覆盖重定向到dump.rdb文件里，每次服务启动会去加载dump.rdb文件里的内容！
			关与手动存盘的命令（在redis命令行里）：
				save		#阻塞存盘，如果在保存过程中，有人要往redis数据库里存数据，是不允许的！
				bgsave	#不阻塞存盘，它是另外启动一个线程做存盘操作
			使用RDB做持久化的时候，相关优化（改配置文件中相应的参数）：
				242行 rdbcompression yes|no	#我把内存中的数据往dump.rdb存储时，是否压缩数据（cpu是处理所有程序运行的）你开压缩，cpu就累...
				251行 rdbchecksum yes|no	#是否校验快照（存快照时使用crc16算法）数据，可以保证数据的完整性，可是cpu又难受了
				236行 stop-writes-on-bgsave-error yes|no	#在redis自动存盘时，是使用的bgsave命令存储的！如果存盘操作出错，是否禁止用户写数据

			RDB持久化的优点：
				它在实现持久化的时候，是创建一个子进程来执行持久化，先将数据写入临时文件，持久化过程结束后，再用这个临时文件替换上次持久化好的文件，
				过程中，客户端正在使用的主进程不做任何操作
				适合大规模数据恢复，且对数据完整性要求不是非常高的场合
			RDB持久化的缺点：
				如果说你系统本来在为客户做大量的存取数据操作，系统很繁忙，你再用RDB来进行持久化，那就卡到GG了
				如果意外服务崩溃了，那最后一次的持久化数据会丢失



		AOF：
			AOF备份文件存放的位置：/var/lib/redis/6379/appendonly.aof
			记录redis的所有更改数据的操作，不断的将新的更改数据的操作，追加到文件的末尾，使用cat可以查看文件内容，默认redis没有启用这项功能
			为了解决RDB最后一次数据存储不上，万一最后一次存储的数据有几十万个，不就全保存不上了吗，aof就是由此而产生的持久化功能	
			AOF在配置文件中的相关参数：
				673行  appendonly no 	#这行是开启AOF的开关，默认是关的
				677行  appendfilename "appendonly.aof"	#指定AOF存数据用的文件名称
				在配置文件中，一共提供了3种AOF存数据的方式：只能使用其中一种
				700行 	# appendfsync always	//有新的更改数据的操作，则立即记录当前内存中的所有数据，
									//追加重定向记录进appendonly.aof文件的同时，覆盖重定向到dump.rdb文件里
				701行  appendfsync everysec	//每秒记录一次，追加重定向记录进appendonly.aof的同时，覆盖重定向到dump.rdb文件里
 				702行  # appendfsync no		//只往appendonly.aof里记录，但是不往dump.rdb文件里记录，每发生一次数据变化就记录
									//不往dump.rdb这个文件里记录，正在运行的redis数据库服务里的变量数据就不会产生变化！

			使用aof的备份文件（appendonly.aof）恢复数据：				
				一旦你执行了删除命令flush all，它也会将其结果追加重定向记录，aof文件就是一个普通的txt文件
				aof恢复数据的步骤：
				比如把55服务器上redis服务的aof备份文件放到56服务器上，让服务器56的redis数据库数据和55上的数据达到一致
				55上的操作：
					将自己服务器里的redis数据库aof备份文件拷贝到56上
					scp /var/lib/redis/6379/appendonly.aof root@192.168.4.56:/root
				56上的操作：				
					1.先将56服务器上的redis服务停掉
					2.将/var/lib/redis/6379/* 内容全部删除
					3.再把55拷贝过来的文件，粘贴到/var/lib/redis/6379/下
					4.如果你aof没有启动，它就不会加载的，所以你要确保aof功能是开的
					5.重启服务即可，它就会自动加载了
			AOF持久化的优化：
				修改主配置文件 /etc/redis/6379.conf相关参数
				首先我们需要知道一点，appendonly.aof这个日志文件是有存储上限的，我们要设置参数，来确定它何时会进行数据重写
				744行 auto-aof-rewrite-percentage 100	
					#当appendonly.aof文件达到64MB，进行第一次重写，也就是下面那条命令
					#比如说重写之后文件大小变成了50MB，那么当第二次这个文件再存50MB数据的时候就会再整理一遍，这个100是一次整理之后的百分比
					#比如第二次整理之后变成80MB，那么第三次整理就是当appendonly.aof文件再写入80MB的时候再整理。以此类推
 				745行 auto-aof-rewrite-min-size 64mb	
					#当appendonly.aof文件大小达到64mb的时候就会进行第一次重写，重写不是删除，而是整理！是把多条同类型命令整理成一条
			AOF日志文件appendonly.aof的修复方法：
				因为这个appendonly.aof文件是文本文件，是可以被修改的，万一对appendonly.aof文件误操作了，会导致整个服务崩溃，由此redis有修复命令
				当appendonly.aof文件出错，你启动服务时，它不会报错，但是你无法对redis正常使用
					命令：redis-check-aof --fix /var/lib/redis/6379/appendonly.aof
						然后Y确认
				不过这个修复功能不是万能的，如果你是对appendonly.aof文件的中间内容操作了，它就可能恢复不回来，再最文件的结尾误操作，它才能恢复

			系统是怎么判断redis服务是否启动了：
				cpu会通过运行redis的脚本去查redis的pid文件是否存在了，只要是存在了，系统就认为你服务启动了，每次redis服务启动，它都会自己去创建这个pid文件
				所有的服务都有它们自己的pid文件！！！写脚本的时候要记住！！！

			AOF的优点和缺点：
				可以灵活的设置持久化方式，同步持久化（ppendfsync always） 或 异步持久化（appendfsync everysec），服务器出现意外down机时，仅可能丢失1秒的数据
				缺点是持久化的文件体积通常会大于RDB持久化的dump.rdb，执行fsync恢复策略时的速度可能会比RDB方式慢，因为它做数据恢复时是主行执行redis命令的
				并且因为要一直处理存操作，机器的性能也会下降

**************************************************************************************************************************************************************************

！！！！！！！！redis的数据类型：string 、list 、hash  及常用数据操作！！！！！！！！！！！！

string类型：只是是set存储的变量都是字符类型，不过你存数字也能存，没那么严格

	set命令存储数据时，默认你的变量就是字符类型的，你set存储变量时，不指定有效期默认是永久有效的
	我们可以给已经存在的变量，重新定义有效时间，方法：
		expire 变量 有效时间秒
	我们也可以在存变量的时候，就给它设置有效期：  
		set key value ex seconds px milliseconds nx|xx
		举个例子：
			set a haha ex 10 nx
			#意思就是，我要创建一个a变量，给它赋值haha，它的有效期是10秒，
			#nx的含义是这个变量a不存在，我们赋值，如果这个变量存在了，本次的赋值操作不生效
			set a lala px 100 xx
			#意思就是我们要给a这个变量赋值lala，它的有效期是100毫秒
			#xx的意思是即使这个变量存在，我们也要用新的覆盖原有的变量，默认不写xx就是用xx		 	
	修改变量的字符串：
		修改字符串：
			比如说我们a这个变量的值是123456789
			除了重新赋值，如果想要修改这个变量的值的方法：
				setrange a 3 ****
				#意思就是改a这个变量，从第三个字符后面开始改，一共改4个字符，改成****
				#这个a的值就变成了 123****89 
		通过命令统计变量个数：
			命令： strlen 变量名
		给变量追加字符：
			命令： append 变量名 值
			#如果这个变量是不存在的，则会创建这个变量，并给其赋值，如果存在就是在变量值的最后追加赋值，并将修改后的变量字符长度显示出来	
		用位（bit）存储数据：关于bit和B的关系可以看Linux基础的解析
			命令： setbit 变量名 偏移量 0或1
			例：
			setbit a 1 0 然后 get a 结果是 0
			setbit a 2 1 然后 get a 结果是 01
			setbit a 3 1 然后 get a 结果是 011
			#我们可以用0或1表示某种状态，这个123是为变量中的第几个字符赋值，这样存储的方式，极大节省空间，因为 8bit 才是一 B
		统计用位（bit）存储的变量中有几个1：
			命令： bitcount 变量名


	redis变量计算：
		将变量中的值减1（要求这个变量存储的值是数值，如果变量值不是数字，则会报错，如果这个变量中没有值，则先初始化为0，再减1）：
			set a 10
			derc a  #是变量a做减1运算，并且将结果重新赋值给这个变量

		将变量中的值，做自定义减法运算（如果变量值不是数字，则会报错，如果变量不存在，则返回null）：
			set b 20
			decrby b 5 #这就是20-5，并且将结果重新赋值给这个变量
			如果你想让它做加法运算，那么就是decrby b -1 ，这样不就变成+1了吗，derc不能做加法运算

		将变量中的值，做加1计算，并显示结果，同时重新赋值这个变量(要求这个变量存储的值是数值，如果变量值不是数字，则会报错，如果这个变量中没有值，则先初始化为0再加1)：
			set f 12
			incr f  #这就是12+1计算，并显示13，并且重新赋值给f
	
		将变量中的值，做自定义加法运算（如果变量值不是数字，则会报错，如果变量不存在，则返回null）：
			set h 15
			incrby h 10 #这就是15+10，并显示25，同时重新赋值给h	
	
		将变量中的值，做自定义的小数加法运算，也可以做减法运算：
			set d 5
			incrbyfloat d 0.5	#加0.5
			incrbyfloat d -0.5  #减0.5		

	redis变量的存储与查询：
		显示变量中的值，并截取显示指定范围：
				set c abcd123
				GETRANGE c 1 3	#显示变量c中的值，起始点是第2位（0是第1位），结束点是第3位，（从右往左显示）显示这部分的值
			显示的结果：bcd
				如果我们想从倒数开始取，则方法如下：
				GETRANGE c -1 -3	#起始点是倒数第1位（-1就是最后一位），结束点是倒数第3位，（从右往左显示）显示这部分的值
				显示的结果：""  是空
				GETRANGE c -2 -2 	#显示的就是2
				GETRANGE c -2 -1	#显示的就是23	

		一次给多个变量赋值：
			set只能给1个变量赋值想要同时给多个变量赋值，要用mset
			mset a 1 b 2 c 3 	#这样不就能给多个变量赋值了吗

		一次获取多个变量的值：
			mget a b c 	#这样就能同时获取多个值

list列表类型：
		可以让一个变量同时存储多个值

	！！！这里有个点一定要注意！！！：你给列表变量赋值，比如lpush a 1 2 3 ，我们输出列表变量a时，它会把3放在列表中（1）的位置，以下的内容，都要结合此条内容来看！！！
	
	lpush a 1 b d		
		#这就是给变量，赋多个值，并且这个变量的类型变成了列表类型，如果你已经有了一个同名的字符型变量，本次赋值会失败，因为这个命令是操控列表类型变量的命令
	你再lpush a h f g ，它并不会给a这个列表类型的变量重新赋值，而是把本次赋的值，追加写进a的列表里，你输出这个列表变量，这个重新写入的值，会在最前面显示，这样a里就有6个值了
		输出a的结果：（1）g （2）f （3）h （4）d （5）b （6）1		
	
	将新的自定义值插入到现有的列表变量里：
		rpush 变量 值1 值2 值3	#这是把值从左往右插入，显示的时候，就是在列表最后显示的，而它lpush那种插入，我们输出列表，是在列表变量中的最前面显示的
			以上面的变量a为例：
				此时变量a的输出是（1）g （2）f （3）h （4）d （5）b （6）1
				我们rpush a aaa bbb
				输出结果：（1）g （2）f （3）h （4）d （5）b （6）1 （7）aaa （8）bbb		

	获取列表变量的值：
		lrange a 0 -1 	#这就是把a这个变量里所有的值全输出，输出的起始点是第1位和最后1位这之间的范围，不过它们输出的结果是从右往左输出
					#输出结果就是 (1)g （2）f （3）h （4）d （5）b （6）1 
		lrange a -2 -1    #输出倒数第2个值和倒数第1个值之间的所有值，包括它们俩，并且是右边的值最先输出
					#输出结果就是 （1）c （2）f
	
	删除列表变量的列表末尾的值：
		rpop 变量
			例：
				lpush a1 a b c d
				lrang a1 0 -1
				结果是：（1）d （2）c （3）b （4）a
				rpop a1
					#它就删除a1列表变量中（4）a这个值，并且将这个值输出				

	输出列表变量中指定的值：
		lindex 变量 0 	#这就是输出列表变量中的第一个值
		lindex 变量 -2	#这就是输出列表变量中的倒数第二个值

	修改列表变量中指定的值：
		lset 变量 1 tom	#这就是把列表变量中的第二个值改成tom

	删除列表边量中的最后一个值（也就是右边数的第一个值）：
		它会把删除的值显示出来，如果变量不存在会输出nil
		lpop a 	#就会把g这个值删除掉了，并且会把g显示出来
	
	统计列表变量值的个数：
		llen a	#有几个值，就会显示几

hash表类型：
	如果我们想让一个变量有列，并且可以是多列，每列都有对应的值，则让变量成为hash表类型即可,这样的好处是方便管理，而且要远比存成字符型变量节省空间

	创建hash类型的变量：	
		例如：我想创建一个变量a5，想让它存储‘name’‘ID’‘test’这几列
			命令：
			hset a5 name bob
			hset a5 ID 123
			hset a5 test 90 

	用一条命令，同时给一个变量创建多列：
		hmset a6 name tom ID 456 test 100  #这就是创建了三列

	获取hash变量中某一列的值：
		以a5为例		 
		hget a5 name 	#这样就会输出bob  	

	获取hash变量中多列的值：
		以a5为例
		hmget a5 name ID test	#这样就会输出bob 123 90
	
	查看hash变量的所有列：
		hkeys a5  	#这样就会输出name ID test
	
	查看hash变量所有列里的值：
		hgetall a5	#这样会输出字段名和字段值，奇数是字段名，偶数是字段值
	如果只想看hahs变量的值：
		hvals a5	#这样就只会输出a5里所有列的值而不会显示列名了
	
	删除hash变量中的指定字段：
		hdel a5 name ID	#这样就会删除name和ID这两列及其列值
	



		

