一、部署redis集群：
	一台客户端虚拟机，要有redis软件
	一共需要6台redis服务器（虚拟机1到6）
	它们的端口号分别是6351、6352.......6356  ip地址是192.168.4.1\4.2\4.3....\4.6

	默认所有的redis是初始配置，这个时候我们要调整它们的配置来开启集群功能：
		先把redis服务停掉
		再去把redis数据库存在内存里的数据清除：rm -rf /var/lib/redis/6379/*
		再去更改配置文件,以192.168.4.1为例：
			vim /etc/redis/6379.conf
			bind 192.168.4.1
			daemonize yes
			port 6351
			cluster-enabled yes				#这是启用集群,在815行
			cluster-config-file nodes-6379.conf		#这是指定集群使用的信息文件，名称可以自定义
			cluster-node-timeout 15000			#单位是毫秒，集群请求超时时间限制，默认是15秒，最好改成5秒
			requirepass ....					#如果设置了密码，一定要把它注释掉，密码的设置在501行，如果你的停服务脚本里有密码的设置也得去删掉
			然后保存退出
		再重启服务
	你集群功能一旦开启，会多开一个集群的端口(端口号是在6351端口的基础上+1万)，还会有一个配置文件/var/lib/redis/6379/nodes-6379.conf
	以上操作，再在其他5台服务器上做同样操作。

******************************************************************************************************************************************************************

二、管理redis集群：	
	此时你只是开启了每一台redis服务器的集群功能，还没有把它们加入到集群里
	在redis命令行里查看集群的状态信息命令：
		cluster info	
	在redis命令行里显示集群中的成员列表命令：
		cluster nodes
	创建集群：
		这里的管理机和代理服务器是不一样的，因为这个集群里的每一台服务器，都可以被客户端访问
		我们需要一台管理服务器（这里我们选“1”），我们可以选中任意一台redis服务器，让它做管理主机，192.168.4.1又当服务机，又当管理机了
		部署管理主机（192.168.4.1）：
			1.控制集群的脚本是用ruby语言写的，所以我们需要去安装ruby语言的解释器,和ruby软件，及依赖包ruby-devel
			这俩软件yum源里没有，在教学环境里的redis-cluster目录里，传给虚拟机，再cd到这个目录里去安装
				yum -y install ruby ruby-devel[tab] 
				yum -y install rubygems 		#装这个软件是为了可以安装ruby运行时所需要调用的第三方软件(redis-3.2.1.gem)，这个软件yum命令装不了
				还要装一个ruby启动时需要调用的第三方软件，这个软件不能用yum命令装，要用rubygems提供的命令装：
				gem install redis-3.2.1.gem
			2.先创建管理集群的命令：
				我们需要进入到redis-4.0.8目录下：cd /root/桌面/redis/redis-4.0.8/src
				里面有个redis-trib.rb可执行文件，这个就是ruby脚本，我们就用这个脚本管理集群
				我们需要把这个脚本拷贝到/root/bin下,也可以放到任意$PATH路径里，并赋予它可执行权限,以后我们就可以不用输入绝对路径来执行命令了：
					mkdir /root/bin
					cp /root/桌面/redis/redis-4.0.8/src/redis-trib.rb /root/bin
					chomod +x /root/bin/redis-trib.rb
				我们可以通过命令：redis-trib.rb help 来查看所有的相关命令
			3.有命令可以用了，现在我们就要开始创建集群了：
				命令：redis-trib.rb create --replicas 1 host:port host:port host:port ...
					#redis集群服务，必须至少要有3台主库服务器，这个 --replicas 1 是说你一台主库有几台从库服务器，至少要1台从库，所以整个集群最少要有6台机器！
					#然后后面host:port这个是集群的成员ip和对应redis服务端口号，你集群有几台，这里就要写几个
					#然后它脚本会自动把最前面的3台机器当作主库服务器，后面的三台当作从库服务器 
					#然后会让你确认配置，输入yes可以
			4.你可以在集群中的任意一台主机上查看集群状态信息
				在redis命令行里查看集群的状态信息命令：
					cluster info	
				在redis命令行里显示集群中的成员列表命令：
					cluster nodes

******************************************************************************************************************************************************************

	在管理主机上检测集群完整信息：
		命令：redis-trib.rb check host:port 
						#写任意一台集群中的主机ip:对应的端口号即可检测完整集群状态
		显示内容如下：	
			M：代表主库	(后面一行16进制数是ID，是在集群中代表的ID) 	
			(slots:5461-10922(5462 slots) #代表的是这个主库槽数的范围，以及使用了多少个槽)	
			(1 additional replica(s) #代表这个主库有几个从库)
			S：代表从库	（ID）	
			(slots (0 slots) #从库没有槽)
			(replicates ID #这是根据集群中哪个ID主机来复制数据的)	！！！一定要用这条信息来确定主从关系！！！
	在管理主机上查看集群中的主库信息：
		命令：redis-trib.rb info  hosot:port
						#写任意一台集群中的主机ip:对应的端口号即可查看完整的集群信息
		显示内容如下：
			主库ip：服务端口号 (在集群中的编号) -> 存了多少变量 | hash槽范围 |  有几个从库 
			主库ip：服务端口号 (在集群中的编号) -> 存了多少变量 | hash槽范围 |  有几个从库 
			主库ip：服务端口号 (在集群中的编号) -> 存了多少变量 | hash槽范围 |  有几个从库 

******************************************************************************************************************************************************************

向集群中添加新的服务器（管理主机linux命令行上操作）：
另外准备两台新的redis服务器（7和8），清空它们的数据库数据，改配置文件开启集群功能，做和上面机器一样的准备！				
		添加主库master服务器的方法：
			需要把主机7添加到集群里，但是此时后添加的7是没有slot槽的，不能存数据，需要分配slot槽
			redis-trib.rb add-node newhost:newport oldhost:oldport
							     #新主机：新主机redis服务端口 集群中已有的任意一台主机ip（最好写管理主机的ip或主库ip）：redis服务端口
			然后给这台新主库加slot槽，将集群中的所有主库slot槽重新分配（重新分片）如果你分错了，重新输入命令重分就可以：
				命令：redis-trib.rb reshard oldhost:oldport
								#集群中的管理主机ip或者任意一台主库的ip：redis服务端口号
				做slot槽重置时，会问你3个问题：
					1.你要将之前所有主库中的slot槽数拿出多少个给新加入的主库用？
						我们需要用 ‘16384/主库数’ 就是你要划分出的slot槽数，这样就可以达到每个主库的槽数平均了！存数据时就平均了！	
						可以用echo $[16384/4] 计算一下得出结果4096个
					2.你要将拿出的4096个slot给哪个主库用？
						写新主库的主机在集群中的ID
					3.指定你要从哪些个主库里拿这些slot槽？
						写all 
						如果只想从某个主库或某几个主库取slot槽数，就写它们的集群ID
					最后yes确认即可
						
		添加新的从库slave服务器的方法：
			先把8这台新的redis服务器准备好，内存啥的都清空，再输入命令：
				redis-trib.rb add-node newhost:newport oldhost:oldport --slave --master-id oldhost:oldport
			#还要加上--slave选项和--master-id做哪个主库主机在集群中的ID，不指定主库的ID，它就自己找从库最少的主库当它的从库,还要写集群中任意一台服务器的IP和端口
	
******************************************************************************************************************************************************************
			
	从集群中移除坏掉的服务器（管理主机上操作）：
		移除主库服务器：
			1.首先要重新分配slot槽（重新分片），把要移除的主库的solt槽释放：
				redis-trib.rb reshard oldhost:oldport
				#集群中的管理主机ip或者任意一台主库的ip：redis服务端口号
				做slot槽重置时，会问你3个问题：
					1）你要将之前所有主库中的slot槽数拿出多少个给新加入的主库用？
						我们需要用 ‘16384/主库数’ 就是你要划分出的slot槽数，这样就可以达到每个主库的槽数平均了！存数据时就平均了！	
						可以用echo $[16384/4] 计算一下得出结果4096个
					2）你要将拿出的4096个slot给哪个主库用？
						写还要留在集群里的主库服务器的集群ID，有几个主库写几个，以达到存储数据时平均分配
					3）指定你要从哪些个主库里拿这些slot槽？
						写我们要移除的主库的集群ID即可，不再指别的了，就输入done结束！
					最后yes即可
					slot槽没了，这个主库之前存的数据也就没了！连它的服务都停了

					如果说你的槽数分配的不平均，可以通过命令让集群自动重置每一个主库的slot槽：
						redis-trib.rb reblance 192.168.4.1:6379
						#告诉系统，哪个主机所在的集群需要重新分配slot槽数，还有redis端口号
			2.上述步骤完成，再移除主库：
				redis-trib.rb del-node oldhost:oldport 主机ID值
				#告诉系统从哪个主机集群里删除这个主库，告诉系统要删除的主库在集群里的ID

		移除从库服务器：
			命令：redis-trib.rb del-node oldhost:oldport 主机ID值
			#告诉系统从哪个主机集群里删除这个从库，告诉系统要删除的从库在集群里的ID

******************************************************************************************************************************************************************

	怎么把移除的服务器重新添加回集群（管理主机上操作）：
		你把服务器从集群中移除，并不会把该服务器的集群文件（/var/lib/redis/6379/nodes-6379.conf）清除的,它只会把移除的redis数据库服务器的服务停掉，
		数据转移给别的主库，所以当你重新把这台移除的数据库启动的时候，它就又加载自己的集群配置文件变回集群里了
		所以我们要去被移除的主机上用命令重置旧的集群配置文件（被移除的机器上操作）：
			需要先启动服务，然后进入redis命令行里输入命令： cluster reset
			

		重新添加移除的主库服务器：
			先去被移除的机器上（比如8吧）清除配置信息
			/etc/init.d/redis_6379 start 
			redis-cli -h 本机redis服务的ip地址 -p 端口
			> cluster reset
			然后再去管理机上执行添加主机的一系列操作：
				添加主库master服务器的方法：
					需要把主机7添加到集群里，但是此时后添加的7是没有slot槽的，不能存数据，需要分配slot槽
					redis-trib.rb add-node newhost:newport oldhost:oldport
									     #新主机：新主机redis服务端口 集群中已有的任意一台主机ip（最好写管理主机的ip或主库ip）：redis服务端口
					然后给这台新主库加slot槽，将集群中的所有主库slot槽重新分配（重新分片）如果你分错了，重新输入命令重分就可以：
						命令：redis-trib.rb reshard oldhost:oldport
										#集群中的管理主机ip或者任意一台主库的ip：redis服务端口号
						做slot槽重置时，会问你3个问题：
							1.你要将之前所有主库中的slot槽数拿出多少个给新加入的主库用？
								我们需要用 ‘16384/主库数’ 就是你要划分出的slot槽数，这样就可以达到每个主库的槽数平均了！存数据时就平均了！	
								可以用echo $[16384/4] 计算一下得出结果4096个
							2.你要将拿出的4096个slot给哪个主库用？
								写新主库的主机在集群中的ID
							3.指定你要从哪些个主库里拿这些slot槽？
								写all 
								如果只想从某个主库或某几个主库取slot槽数，就写它们的集群ID
							最后yes确认即可
		重新添加从库服务器：
			先去被移除的机器上（比如8吧）清除配置信息
			/etc/init.d/redis_6379 start 
			redis-cli -h 本机redis服务的ip地址 -p 端口
			> cluster reset
			然后再去管理机上执行添加主机的一系列操作：
				添加新的从库slave服务器的方法：
				先把8这台新的redis服务器准备好，内存啥的都清空，再输入命令：
				redis-trib.rb add-node newhost:newport oldhost:oldport --slave --master-id oldhost:oldport
			#还要加上--slave选项和--master-id做哪个主库主机在集群中的ID，不指定主库的ID，它就自己找从库最少的主库当它的从库,还要写集群中任意一台服务器的IP和端口	

******************************************************************************************************************************************************************

四、测试集群
	客户端访问redis数据库服务器，要求客户端也有redis，命令如下
	redis-cli -c -h 192.168.4.1 -p 6379 
	# -c 选项意思是我要访问集群！ -h 后写集群中的任意一台服务器，可以是主库也可以是从库， -p 是使用指定端口号，如果有密码就加 -a 选项
	#这里有一个牛逼的地方，即使你访问的是从库，你写数据，它也是跑到主数据库上去写，然后再同步给这台从库服务器，你访问从库做查询数据操作，也是跳到主库上查
	#所以建议连就连主库，因为不管你存取数据其实都是在主库上存取数据的！
	#当你以集群的方式访问某一台从库主机时，你存数据，它就是往对应的主库服务器里存，
	#如果你不访问集群这一组主从服务器（1和4），去访问集群中另一组主从服务器（2和5）时，你想查在（1和4）那组服务器中存的数据，也可以查到
	#但是你以集群的方式存数据时，它却不一定就存到你访问的主库里，这就要看下面的集群工作原理了	
	#不过你登陆一台主机，使用命令 keys * 查看到的只是本组主从机上的所有变量，你要想看别的主从机里的变量，就需要指定变量名了

******************************************************************************************************************************************************************

五、集群的工作原理：
	这个slot值不是决定数据存储容量的！！！slot值的范围，就是用来确定数据存放在哪台主库服务器上的！！！
	我们访问集群中的一台服务器时，当我们要查询一个当前服务器没有的变量时，这台redis服务器会跑去别的集群服务器上查，并计算一个slot值（这个slot也叫hash槽）
	这个slot槽的个数范围是0-16383 当我们创建集群时，redis就会自动去平均分配这些slot槽给主库
	然后当客户端连接了一台主库时想存变量时，系统就会用：
		变量与crc16算法做hash计算，将得出的结果与16384做取余运算，最后所得结果就是slot值，它用来确定去哪台服务器存数据）
		也就是如下内容：Redirected to slot [16287] located at 192.168.4.3:6379
	当客户要在集群中取数据时：
		也是将变量名与crc16算法做hash运算，将结果与‘16384’取余，最后所得结果就是用来确定变量在哪台服务器里的solt值

******************************************************************************************************************************************************************

六、关于集群中的高可用功能
	高可用：当主库服务器坏掉的时候，对应的从库服务器自动升级为主库服务器
	我们可以来测试一下高可用的功能：
		我们把一台主库服务器redis服务停掉，来看效果：
			我们会发现那台坏掉的主库，它对应的从库服务器，自动变成了主库服务器，通过这种方式来保证集群中至少有3台主库服务器
		那么我们再把这个关掉的主库服务器，再启动，来看效果：
			我们除了重启服务，没做任何操作，它的配置还是以前的配置，它会自动成为从库最少的主库服务器的从库！
			并且它会自己去主库服务器上去同步数据！
		能达到上述效果，是因为这台服务器并没有被集群移除！
	我们可以给每个主库设置两个从库，等等高可用的架构设计。






