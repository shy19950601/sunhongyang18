一、mongodb副本集（高可用集群）
	mongodb数据库里的三个系统库：
		admin：存放授权信息的
		config：存放分片信息
		local：存放本机配置信息
	1.副本集介绍：
		在多个mongodb服务器上存储相同数据，并实现主从同步，提高安全性，方便数据恢复，在这里从库服务器叫副本
		副本集工作过程：
			至少需要两个节点（一主一从），主节点负责处理客户端请求，其余服务器负责复制主节点数据，这里没有代理服务器
			常见搭配都是一主一从，或者一主多从
			主节点记录所有操作日志，从库服务器定期去访问主库的日志文件，来同步数据
		副本集的实现方式（老版本）：现在不用这种方式了，这种方式无法自动修复
			启动服务时，加上 “-master”宣告主库身份，它就会作为主节点（主库）启动了
			启动从库服务器的服务时，加上 -slave 宣告从库身份 和 -source+指定主库，就会作为从库启动了
		副本集的实现方式（1.6版本）：Replica Sets副本集
			支持故障自动切换，当主库坏掉的时候，从库自动升级为主库；
			当你损坏的那个主库修好的时候，它会自动成为当前集群里主库的从库，并且自动把数据同步过来；
			一切都是自动的，极大的降低了运维成本；
			既实现了高可用集群，又能做主从同步数据备份！			
		主从复制的优点：
			从节点可以提供数据查询，降低主节点的访问压力
			从节点执行备份，避免锁定主节点数据
			当主节点故障时，可快速切换到从节点，也就是从库自动变为主库，实现高可用！	
	2.配置副本集
		Replica Sets副本集配置方法：
		准备3台服务器51 52 53，51做主节点，52 53做从节点
		1.在所有成员51、52、53的配置文件里，启用集群功能：
			vim /usr/local/mongodb/etc/mongodb.conf
			写入一行：
			replSet=rs1  #rs1是我们自定义的集群名称
		2.启动服务时，指定主机所在副本集名称，集群里的所有成员使用相同的副本集名称：
			/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/etc/mongodb.conf --replSet rs1 
				#名称随便起，和主配置文件里的一样，以后所有成员启服务时都用这个名称，主配置文件里写了就不用写 --replSet rs1，这个选项是临时启用集群
		3.在主库服务器上，添加集群成员：
			先进入51的mongodb：/usr/local/mongodb/bin/mongo --host 本机网卡的ip --port 27017
			输入以下内容：
				> config={        					//config随便起变量名,要记住
				 _id:"rs1",         					//rs1是集群名称，配置文件里面写的是这个
				 members:[							
				 {_id:0,host:"192.168.4.51:端口号"},        	//_id值随意，host值固定
				 {_id:1,host:"192.168.4.52:端口号"},
				 {_id:2,host:"192.168.4.53:端口号"}
				 ]
				 };        //回车
			出现下面情况为成功
				{
				    "_id" : "rs1",
				    "members" : [
					{
					    "_id" : 0,
					    "host" : "192.168.4.51:27077"
					},
					{
					    "_id" : 1,
					    "host" : "192.168.4.52:27078"
					},
					{
					    "_id" : 2,
					    "host" : "192.168.4.53:27079"
					}
				    ]
				}
				>
			在51主节点上创建集群：
				> rs.initiate(config)		#这个config是成员列表的变量名
				创建完集群之后，命令行提示符会发生变化
			创建完之后，可以在当前机器上输入以下命令查看当前服务器是不是主节点：
				> rs.isMaster 	#每个节点都可以用这条命令查看状态
			
		#从库都是只读的，默认从库是无法操作数据的，这个副本集信息被存放到了51的mongodb数据库里了，存放到了local库里，
		#如果你想重新配置集群，就应该去三台节点里，把local库删除掉，然后重新配置
		#如果集群配置中间出错了，解决方法（三台节点都要这么做）：
			先停掉服务
			去配置文件里注释掉集群功能
			启动服务然后进入mongodb里把local库删除掉
			再停掉服务，把集群功能开启
			然后再做创建集群的操作
	
	3.查看集群配置信息：
		> rs.status()
		显示信息如下：
		> rs.status()
			...
			    "members" : [		
				{	
				    "_id" : 0,				#id是0的那台节点
				    "name" : "192.168.4.51:27077",	
				    "health" : 1,				#1说明这台机器是活跃的
				    "state" : 1,				#主库的状态值是1
				    "stateStr" : "PRIMARY",		#是主节点的意思
				    "uptime" : 2295,
				    ...
			...
				},
				{
				    "_id" : 1,
				    "name" : "192.168.4.52:27078",
				    "health" : 1,	
				    "state" : 2,				#从库的状态值是2
				    "stateStr" : "SECONDARY",		#从库的意思
				    "uptime" : 384,
            ...	
	4.验证配置
		1）测试主从同步：
			50客户端连接51主库：
				存几条数据
				/usr/local/mongodb/bin/mongo --host 192.168.4.51 --port 27017
				db.t1.save({a:123})
			然后去52从库或者53从库上查看数据：
				默认52和53是无法操作数据的，所以输入命令,使其52可以临时对数据进行操作：
				> db.getMongo().setSlaveOk()
		2）测试高可用：
			把51主库的mongodb服务停掉，看52或者53是否自动切换主库了
			如果52切换为主库了，53是否自动去52上同步数据了
			当51重新启动服务之后，是否会自动成为52的从库，并自动把52的数据同步过来了
	5.集群的工作过程：
		假如你希望创建集群时，可以指定节点为主库，可以在创建集群的时候，指定每一台节点的优先级：
				> config={        					//config随便起变量名,要记住
				 _id:"rs1",         					//rs1是集群名称，配置文件里面写的是这个
				 members:[							
				 {_id:0,host:"192.168.4.51:端口号",prioicy:20},        	//如果都不指定优先级，就是在哪台节点上创建集群，哪台机器就是主库
				 {_id:1,host:"192.168.4.52:端口号",prioicy:15},		
				 {_id:2,host:"192.168.4.53:端口号",prioicy:10}		//prioicy是优先级，数值越小越优先，这时候53这台机器在创建集群时就是主库
				 ]
				 };        //回车		
		当主库服务器故障时，它是怎么选举别的主库的呢：
			哪台从库的数据最接近原主库，就会被选举为主库，不过也不会立刻就成为主库，还需要30秒的等待 	

二、文档（表记录）管理
	1）查询文档
		db.t1.findOne() 	#查看t1表里第一行的内容
		db.t1.find()	#它会自己创建一列id字段，并自己赋值，虽然它是查看表里所有值的命令，但是一次最多只会显示20行，想再看20行需要输入"it"
		db.t1.find({},{})	#第一个{}是写条件，也就是说我想看哪一列，什么都不写，就是看所有列，第二个{}是第二个条件，比如我写个_id:0，就是说我不想看这个字段！
			例如：
				db.t1.find({},{_id:0}) 		#给我显示所有行所有列，但是我不要看_id这列，0就是不显示，1就是显示
				db.t1.find({},{_id:0,age:1})	#显示所有行和列，但是不显示_id字段，只显示age字段的值
				db.t1.find({},{age:1})		#这是只显示age字段，不过_id字段也会显示，别的字段不会显示 
				db.t1.find({age:18},{age:1})	#这就是说显示age字段值是18的行，后面的{}是说显示age字段！
				db.t1.find({age:18})		#这就是显示age字段值是18的行，然后显示这些行的所有列
		db.t1.find().limit(3)	#这就是把显示结果中的前三行显示出来
		db.t1.find().skip(2) 	#这就是把显示结果中的前2行忽略，显示其它行
		db.t1.find().sort({age:1})	#这就是把显示结果，按age字段值的升序排列（最小的最先显示）显示，age字段的值必须是数字，-1就是按降序排列显示
		db.t1.find().count()	#统计显示结果有多少行
	2）插入文档
		db.表名.save({key:"值",key2:"值"},{key3:"值",key4:"值"})
			当表不存在时，会创建表，然后再插入记录
			如果你插入数据的时候，写了_id字段，当这个_id字段值已存在时，修改对应_id字段的表记录里的字段值
			如果你插入数据的时候，写了_id字段，当这个_id字段值不存在时，插入表记录
			可以写多个{}，也就是同时往表里插入多行
			这个_id字段就是每一行记录的标识，你不赋值，系统自动计算并赋值，然后每一行表记录的_id字段都会做自增长赋值
		db.表名.insert({key:"值",key2:"值"})
			当表不存在时，会创建表，然后再插入记录
			如果你插入数据的时候，写了_id字段，当这个_id字段值已存在时，放弃插入
			如果你插入数据的时候，写了_id字段，当这个_id字段值不存在时，插入表记录
			只可以写一个{}，也就是只可以同时插入一行，想插入多行，要用insertMany()
		db.表名.insertMany([{key:"值",key2:"值"},{key3:"值",key4:"值"}])
			当表不存在时，会创建表，然后再插入记录
			如果你插入数据的时候，写了_id字段，当这个_id字段值已存在时，放弃插入
			如果你插入数据的时候，写了_id字段，当这个_id字段值不存在时，插入表记录
			可以插入多行,也就是多个{}
	3）更新文档：
		3.1）改符合条件的第一行：
			db.t1.update({uid:{$lte:5}},{name:"tom"})
			# 即使有多行符合条件，它也只会改符合条件的第一行，并且只留下了要改的字段，其它的字段都删除，不过_id字段不会删除！

		3.2）改符合条件的所有行，只改指定的字段：
			db.user.update({name:"adm"},{$set:{password:"AAA"}},false,ture)
			# $set是告诉系统，只改指定字段，不删除其它字段，false,ture是告诉系统改所有符合条件的行！

		3.3）删除指定行的指定字段：
			db.user.update({uid:{$lte:5}},{$unset:{password:mima}})   
			# 删除符合条件的行，删的是password字段值是mima的字段及值，这个只会删除符合条件的第一行

		3.4）删除符合条件的多行的多个字段：
			db.user.update({uid:{$lte:5}},{$unset:{password:mima}},false,ture)
			# 删除所有符合条件的行，删的是password字段值是mima的字段及值，有多少行多少字段符合条件就删除几行

		3.5）修改指定数值字段，使其字段值自增或自减：
			db.user.update({uid:{$lte:10}},{$inc:{uid:2}})
			# 条件匹配时，字段值自加或自减，正数就是自加，负数就是自减，要求字段值必须是数值型          
	4）删除文档
		4.1）remove()删除文档时不删除索引（排队信息），当你删的是所有表记录的时候，表不会删除，因为必须要加{}条件限制的
			db.t1.remove({})
			//这是删除t1表里的所有表记录
			db.t1.remove({uid:{$lte:10}})
			//这就是删除uid小于等于10的所有行！
		4.2）drop()删除集合的时候同时删除索引（排队信息），会把表记录删的干干净净，当你删除的是所有表记录的时候，表也会被删除
			db.t1.drop() 
			//删除t1表
	5）数组类型的操作命令
		5.1）$push 向数组中添加新元素
			db.user.update({name:"bob"},{$push:{hobby:"Z"}})        
			//找到name是bob的行，往hobby数组里加一个“Z”,这个值会被加到数组的最后，而且这个值是可以和数组里的值重复的。

		5.2）$addToSet 避免重复添加
			db.user.update({name:"bob"},{$addToSet:{hobby:"Z"}}) 
			//如果这个数组里已经存在我们要存的这个值了，则不添加，反之则添加

		5.3）$pop 删除数组末尾一个元素，1删除最后一个，-1删除第一个
			 db.user.update({name:"bob"},{$pop:{like:1}}) 
			//这就是删除like这个数组里的最后一个值
		
		5.4）$pull 删除数组里的指定元素，若有两个bob可以用_id值定义把name:"bob"换成id值
			db.user.update({name:"bob"},{$pull:{like:"c"}})
			//这就是把数组里的值是c的删除，有几个c删除几个！	

	6）查询、插入、更新、删除文档的匹配条件：
		相等比较匹配：条件成立就显示，不成立就不显示
			例如：db.t1.find({uid:10})	#用uid字段值和1做比较，相等则显示
		逻辑与比较匹配：多个条件都要同时成立
			例如：db.t1.find({uid:10,name:"bob"})	#每个条件都要成立才可以
		逻辑或比较匹配：满足其中一个条件即可		
			例如：db.t1.find({$or:[{name:"bob"},{age:18},{uid:1}]},{_id:0,uid:1,name:1,age:1})
				#显示满足{name:"bob"},{age:18},{uid:1}这3个条件之一的行，然后只显示uid,name,age这三列
		范围比较匹配：
			$in 在...里：
				db.user.find( { uid:{ $in:[1,6,9] } } )
				#uid的值为1或者6或者9的匹配，没有空格，一定要看仔细符号
			$nin 不在...里：
				db.user.find({uid:{$nin:[1,6,9]}},{_id:0,name:1,uid:1})
				#也就是uid不是1，6，9的行，并且只显示name和uid字段
		正则匹配：
			db.t1.find({name:/^[tb]/})
				#给我匹配name字段值是以t开头，或者以b开头的行，有多个字符的时候要用[ ] 框上
			db.t1.find({name:/b/})
				#给我匹配name字段值中有b的行
		数值比较匹配：
			$gt 	大于
			$gte	大于等于
			$lt	小于
			$lte	小于等于
			$ne	不等于
				db.user.find({uid:{$gte:10})
				#找uid大于等于10的行
				db.user.find({uid:{$gte:10,$lte:40}},{_id:0,name:1,uid:1})
				#给我找uid值大于等于10并小于等于40的值的行，并只显示其name字段和uid字段
		匹配空：
			db.user.save({name:null,uid:null})
			#存空
			db.user.find({name:null,uid:null})
			#找name、uid字段值是空的行
	
		
	












